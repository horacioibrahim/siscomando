<!--
@license
Copyright (c) 2016 Horacio Ibrahim. All rights reserved.


An element providing a solution to connect remote server and catch data.

Example:

    <sc-remote></sc-remote>

Remember to set headers in th backend. e.g.:

Access-Control-Allow-Headers: Content-Type,Authorization
Access-Control-Allow-Methods: GET,POST,PUT 
Access-Control-Allow-Origin: https://api.myapi.com

TODO: 
    - We can to appreciate check an "updated" field for conditional requests with
      "If-Modified-Since"
    - We can to appreciate... "etag" for conditional requests as "If-None-Match"
    - Expires date customised (or not) can help us as a strategy to cache behavior. See
    below image for more intuition.
    (http://betterexplained.com/wp-content/uploads/compression/HTTP_caching_expires.png)
    - Or rather Expires date to use "max-age".
    - sessionKey/tokenKey (or JWT token) is importante for all requests. The server will 
    handle if or not reply the request based on sessionKey is expired r not. More:
    http://stackoverflow.com/questions/20963273/spa-best-practices-for-authentication-and-session-management#answer-28259165 (Remember: Authorization: Bearer <token>)
    - We to handler HTTP 401 Not Authorized status when sessionKey expired or not 
    authorization must to generate 

@demo demo/index.html
@hero hero.svg
-->

<dom-module id="sc-request">
    <template>
        <iron-ajax id="ajax"
           url={{url}}
           method="{{method}}"
           handle-as="json"
           on-response="_handleResponse"
           debounce-duration="300"
           withCredentials="true"></iron-ajax>  
         <sc-cache expires-time="{{expiresTime}}" id="cache"></sc-cache>
    </template>
    <script>
        Polymer({
            is: 'sc-request',
            properties: {
                output: {
                    type: String,
                    readOnly: true,
                    reflectToAttribute: true
                },
                hashable_url: String,
                auto: {
                  type: Boolean,
                  value: true
                },
                url: {
                  type: String,
                  observer: "_changedConfig"
                },
                method: {
                    type: String,
                    value: "GET"
                },
                body: {
                    type: Object,
                    observer: "_changedConfig"
                },
                contentType: {
                    type: String
                },
                headers: {
                    type: String
                },
                method: {
                    type: String
                },
                response: {
                    type: Object
                },
                withAuth: {
                  type: Boolean,
                  value: true
                },
                handleAsync: Object,
                /** `responseFromRequest` response from iron-ajax */
                responseFromRequest: Object,
                /** `responseFromCache` response from sc-cache */
                responseFromCache: Object,
                expiresTime: {
                    type: Number,
                    value: 10
                },
                /** `jsonToken` a token for all requests. This token can be 
                * generate by JWT flow.
                */
                jsonToken: String,
                authMethod: {
                    type: String,
                    value: 'Basic' // Bearer, Token, etc...
                }
            },
            ready: function() {
              // set headers default for SPA context
                if (this.withAuth) {
                    var headers = {}
                    // TODO: ask sc-login instead get from sessionStorage?
                    var token = JSON.parse(sessionStorage.getItem(siscomando.SESSION_KEY)); 
                    headers['Authorization'] = this.authMethod + ' ' + token;
                    this.headers = headers;                    
                }
            },
            /** `_changedConfig` to change sc-cache properties
            */
            _changedConfig: function() {
                var ajax = this.$.ajax;
                this.hashable_url = this._nameFromUrl(this.url);
                ajax.url = this.url ? this.url : undefined;
                ajax.body = this.body ? this.body : undefined;
                ajax.method = this.method ? this.method : undefined;
                ajax.contentType = this.contentType ? this.contentType : undefined;
                ajax.headers = this.headers;
                
                if (this.auto) {
                    this.checkCache();    
                }
                
            },
            /** `_nameFromUrl` creates a hashable token from url
            */
            _nameFromUrl: function(url) {
                return url.replace(/[\:\/\%\?\&\.\=\-\,]/g, '_') + '_api';
            },
            /** `go` calls checkCache. 
            */
            go: function() {
              this.checkCache();  
            },
            checkCache: function(){
                var self = this;
                var cache = this.$.cache;
                cache.getCache(self.hashable_url);
                cache.addEventListener('sc-cache', function(evt){
                    if (evt.detail.response) {
                        // Main action
                        var expires = evt.detail.response.expires;
                        self.responseFromCache = evt.detail.response.response;
                        self._responseAfterFlow(evt.detail.response.response);  
                        // to canel any previous async.
                        self.cancelAsync(self.handleAsync); 
                        
                        // check if response is expired so make update.
                        if (self.checkExpired(expires)) {
                            self._callBackRequest();    
                        }
                    } else  {
                        self._callBackRequest();
                    }
                    // or runs async tasks for update cache. To verify if response
                    // from iron-ajax is not equal response from cache.
                    // self.handleAsync = this.async(self._callBackRequest(), 300);
                });
            },
            _callBackRequest: function() {
                this.$.ajax.generateRequest();
            },
            /** `_handleResponse`
            */
            _handleResponse: function(evt) {
                var cache = this.$.cache;
                var hashable_url = this.hashable_url;
                var response = evt.detail.response;
                self.responseFromRequest = response;
                // Main action
                this._responseAfterFlow(response); // levanta o evento
                if (!this.responsesIsEquals()) {
                    cache.putCache(hashable_url, response); // atualizao cache com novos informacoes.    
                }
            },
            _responseAfterFlow: function(response) {
                this.fire("sc-request-response", {"response": response});
            },
            /** `checkExpired` returns true if cache data is expired or false
            * if not expired. 
            * 
            * @response This is the responsefromCache.
            */
            checkExpired: function(expires) {
                var now = new Date();
                if (now > expires) {
                    return true;
                }
                return false;
            },
            responsesIsEquals: function() {
                // Now is time to compare:
                if (this.responseFromCache && this.responseFromRequest) {
                    if (JSON.stringify(this.responseFromCache) === JSON.stringify(this.responseFromRequest)) {
                        return true;       
                    }        
                }
                return false;
            }
            
        });
    </script>
</dom-module>
